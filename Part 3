#include <msp430.h>

#define RedLED BIT0

volatile char state = 0;
volatile char timeCounter = 0;
volatile char LED_ON = 0;

int main(void)
{
  WDTCTL = WDTPW + WDTHOLD; // Stop watchdog timer
  P1DIR |= (RedLED);  // Set P1.0 to output

  P1OUT &= ~RedLED;

  BCSCTL3 |= LFXT1S_2;

  TACCR0 = 10000 - 1;
  TA0CCTL0 = CCIE;
  TACTL = TASSEL_1 + MC_1;

  __enable_interrupt();

  while(1)
  {
    /*P1OUT |= RedLED;
    __delay_cycles(10000);
    P1OUT &= ~RedLED;
    __delay_cycles(1000000);
    */
  }
}

#pragma vector = TIMER0_A0_VECTOR
__interrupt void TimerA (void)
{
  if (!LED_ON)
  {
    timeCounter = (timeCounter + 1) % 10;
  }

  if (timeCounter == 0)
  {
    if (!LED_ON)
    {
      P1OUT |= RedLED;
      LED_ON = 1;
      TACTL |= TACLR;
      TACCR0 = 999;
    }

    else 
      {
        P1OUT &= ~RedLED;
        LED_ON = 0;
        TACTL |= TACLR;
        TACCR0 = 9999;

        switch (state)
        {
          case 0:
            __bic_SR_register_on_exit(LPM3_bits);
            state++;
            break;

          case 1:
            __bis_SR_register_on_exit(LPM0_bits | GIE);
            state++;
            break;

          case 2:
            __bic_SR_register_on_exit(LPM0_bits);
            __bis_SR_register_on_exit(LPM3_bits | GIE);
            state = 0;
            break;
        }
    }
  }
}

