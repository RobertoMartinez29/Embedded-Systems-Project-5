#include <msp430.h>
#define RedLED BIT0
#define GreenLED BIT6
#define LED_OUT P1OUT
#define LED_DIR P1DIR

volatile unsigned int timer0Count = 0;
volatile unsigned int timer1Count = 0;
int greenDelay [] = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19};
char index = 0;

void main(void)
{
  WDTCTL = WDTPW + WDTHOLD;    // Stop watchdog timer
	LED_DIR |= (RedLED + GreenLED);  // Set P1.0 and P1.6 to output direction
	LED_OUT &= ~(RedLED + GreenLED); // Set the LEDs off
	TACCR0 = 30000;              // Set the TimerA0 CC0 LED delay
  TACCR1 = 10000;
	TA0CCTL0 = CCIE;             // enable the interrupts from TimerA0 CC0
  TA0CCTL1 = CCIE; 
	TACTL = TASSEL_2 + MC_2;     // Set the timer A to SMCLCK, Continuous

	__enable_interrupt();        
	while(1)
  {
    __delay_cycles(500000);
    LED_OUT ^= RedLED;
  }
}

#pragma vector=TIMER0_A0_VECTOR
__interrupt void Timer_A (void) // Timer A0 interrupt service routine
{
  TACCR0 += 30000;
 timer0Count = (timer0Count + 1) % greenDelay[index]; // roll back over to zero after 8 interrupts
 if(timer0Count == 0)
     P1OUT ^= (GreenLED);  // toggle LED's on the 8th time
}

#pragma vector=TIMER0_A1_VECTOR
__interrupt void Timer_A1 (void)
{
  switch (TA0IV) 
  {
    case TA0IV_TACCR1:
      TACCR1 += 10000;
      break;

    case TA0IV_TACCR2:
      break;

    case TA0IV_TAIFG:
    break;
  }

  timer1Count = (timer1Count + 1) % 10000;
  if(timer1Count == 0)
      index = (index + 1) % 10;
}
